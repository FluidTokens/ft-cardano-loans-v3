diff --git a/lib/finance.ak b/lib/finance.ak
index 1718635..431831c 100644
--- a/lib/finance.ak
+++ b/lib/finance.ak
@@ -64,9 +64,12 @@ pub fn get_repayment_amount(
           totalInstallments,
         )
       let denominator =
-        rational_pow(
-          rational.add(oneAsRational, interestPerInstallmentAsRational),
-          totalInstallments - 1,
+        rational.sub(
+          rational_pow(
+            rational.add(oneAsRational, interestPerInstallmentAsRational),
+            totalInstallments
+          ),
+          oneAsRational
         )
       expect Some(result) = rational.div(numerator, denominator)
       if isLate {
diff --git a/lib/types/datum.ak b/lib/types/datum.ak
index a39f47e..ead6822 100644
--- a/lib/types/datum.ak
+++ b/lib/types/datum.ak
@@ -6,8 +6,7 @@
 //If the penalty fee should be sent to an address different from the lender, then the lender nft must be locked in a dedicated contract that says so.
 //Loan refinancing is done spending the new loan and the old loan in the same tx.
 use cardano/address.{Address}
-use cardano/assets.{AssetName}
-use cardano/transaction.{Datum}
+use cardano/assets.{AssetName, Value}
 use types/general.{Asset, CollateralAsset}
 
 pub type ConfigDatum {
@@ -79,7 +78,26 @@ pub type PoolDatum {
   //True if borrowable amount of the collateralOptions must be updated through oracles
   dynamicCollateralPrice: Bool,
   //Place this output in the output of the lender token, useful if the lender is a SC.
-  lenderTokenOutputOptionalDatum: Datum,
+  lenderTokenOutputAdditionalData: Data,
+}
+
+// It would be nice to also include Pool information as well as collateral value
+// in principal units in the LenderTokenOutputDatum.
+//
+// However since faking loans attributed to a lender is current possible we only
+// care about having the loan information to verify profit/loss onchain in the
+// legitimate loan case. Fake repayments can also skew profit/loss onchain
+// verification, but that's less of an issue.
+//
+// Additionally, to verify profit/loss onchain for the lender for
+// totalInstallments > 1 with the `InterestOnRemainingPrincipal` mode the
+// repayments would also need to include their repayment count. We'd probably
+// need more information in the recasts case but I haven't actually looked into
+// what recasts are.
+pub type LenderTokenOutputDatum {
+  activeLoanValue: Value,
+  activeLoanDatum: ActiveDatum,
+  additionalData: Data
 }
 
 pub type ActiveDatum {
diff --git a/validators/pool_withdraw.ak b/validators/pool_withdraw.ak
index 7481f78..179657c 100644
--- a/validators/pool_withdraw.ak
+++ b/validators/pool_withdraw.ak
@@ -8,7 +8,7 @@ use cardano/assets.{Value, flatten, quantity_of}
 use cardano/transaction.{
   Datum, InlineDatum, Output, OutputReference, Transaction,
 }
-use types/datum.{ActiveDatum, Liquidation, PoolDatum}
+use types/datum.{ActiveDatum, Liquidation, PoolDatum, LenderTokenOutputDatum}
 use types/general.{Asset, CollateralAsset}
 use types/redeemer.{
   Aggregated, Borrow, Cancel, Dedicated, OraclePriceFeed, PoolWithdrawRedeemer,
@@ -107,8 +107,9 @@ validator pool(
                   borrowerTokenPolicyId,
                   lenderTokenPolicyId,
                   inputUtxoId,
-                  datum.lenderAddress,
-                  datum.lenderTokenOutputOptionalDatum,
+                  datum,
+                  activeOutput.value,
+                  activeOutput.datum
                 ),
                 if datum.dynamicCollateralPrice {
                   let oracleRefInput =
@@ -190,14 +191,26 @@ fn tokens_sent_to_both_parties(
   borrowerTokenPolicyId: ByteArray,
   lenderTokenPolicyId: ByteArray,
   inputUtxoId: ByteArray,
-  lenderAddress: Address,
-  lenderTokenOutputOptionalDatum: Datum,
+  poolDatum: PoolDatum,
+  activeLoanValue: Value,
+  unparsedActiveLoanDatum: Datum,
 ) {
+  let lenderAddress = poolDatum.lenderAddress
+  let additionalData = poolDatum.lenderTokenOutputAdditionalData
+
+  // This is done in validate_output_to_active_with_oracle and
+  // validate_output_to_active_with_oracle so maybe factor them out?
+  expect InlineDatum(datum) = unparsedActiveLoanDatum
+  expect activeLoanDatum: ActiveDatum = datum
+
+  let expectedLenderTokenOutputDatum =
+    LenderTokenOutputDatum{activeLoanValue, activeLoanDatum, additionalData}
+
   and {
     quantity_of(mintedValue, borrowerTokenPolicyId, inputUtxoId) == 1,
     outputWithLenderToken.address == lenderAddress,
     quantity_of(outputWithLenderToken.value, lenderTokenPolicyId, inputUtxoId) == 1,
-    outputWithLenderToken.datum == lenderTokenOutputOptionalDatum,
+    outputWithLenderToken.datum == InlineDatum(expectedLenderTokenOutputDatum),
     length(flatten(outputWithLenderToken.value)) <= 5,
   }
 }
